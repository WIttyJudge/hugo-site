[{"content":"In TCP, each segment consist of data that are sent to the receiver\u0026rsquo;s server. Alongside the data, the TCP segment contains header which holds information about the connection and the current data being sent. The TCP header size can range from 20 bytes (160 bits) to 60 bytes (480 bits), with 20 bytes designated for 10 mandatory fields and 40 bytes for optional.\nThe table of TCP header is shown bellow:\nField Size (bits) Description Source Port 16 Sender\u0026rsquo;s port number Destination Port 16 Receiver\u0026rsquo;s port number Sequence Number 32 Sequence number of the first data byte Acknowledgment Number 32 Next sequence number expected Header Length 4 Length of TCP header in 32-bit words Reserved 6 Reserved for future use Flags 6 Control flags (SYN, ACK, FIN, RST, PSH, URG) Window Size 16 Receiver\u0026rsquo;s buffer size Checksum 16 Error detection checksum Urgent Point 16 Offset indicating urgent data Options 0-320 Optional parameters Source Port - identifies the port of the sending application.\nDestination Port - identifies the port of the receiving application.\nSequence number - indicates the sequence number of the first data byte in the TCP segment. It helps to ensure that data is correctly ordered and reassembled at the receiver.\nAcknowledgment number – If the ACK flag is set, this field contains the acknowledgment number of the next expected data byte by the sender. It acknowledges the receipt of previously received data.\nHeader Length (HLEN) - Also know as the Data Offset, it specified the size of the TCP header in 32-bit words. The minimum size header is 5 words (20 bytes) and the maximum is 15 words (60 bytes).\nReserved - comprises a few bits that are currently set to zero and are reserved for possible future use by the TCP protocol or related specifications.\nFlags - indicate specific conditions or actions related to the TCP communication. Here is a list of commonly used flags:\nSYN (Synchronize) is used to initialize TCP connection. When a device wants to establish connection with another device, which is also called a three-way handshake, it sends a TCP segments with SYN flag.3 ACK (Acknowledge) is used by receiving device to confirm that the data was successfully received. FIN (Finish) is used when device want to terminate connection. The name of this process is four-way handshake. RST (Reset) signifies that we should immediately terminate the connection. It can happen because of many things, for example: connection aborted, TCP port doesn\u0026rsquo;t exist, TCP buffer overflow, etc.. PSH (Push) indicates that the data sent to the receiver is important and should be forwarded to the application without delay. URG (Urgent) is used to inform a receiving device that certain data within a segment is urgent and should be prioritized. Mostly, it is used for time-sensitive data. Window Size is used by mechanism called Flow Control and indicates the maximum amount of data receiver can handle. Flow control mechanism regulates the rate of data transmission to prevent congestion, packet loss, and degradation of network performance.\nChecksum - field holds the checksum for error control. It is mandatory in TCP as opposed to UDP.\nUrgent Point - If the URG flag is set, it provides more specific information about the location of the urgent data within the segment.\nOptions- optional and can be anywhere between 0 and 40 bytes (320 bits).\n","permalink":"https://wittyjudge.github.io/posts/tcp-header/","summary":"In TCP, each segment consist of data that are sent to the receiver\u0026rsquo;s server. Alongside the data, the TCP segment contains header which holds information about the connection and the current data being sent. The TCP header size can range from 20 bytes (160 bits) to 60 bytes (480 bits), with 20 bytes designated for 10 mandatory fields and 40 bytes for optional.\nThe table of TCP header is shown bellow:","title":"TCP Header"},{"content":"I have been using Arch Linux for about 3 years now and only recently I needed to print and scan documents with my office printer (Canon MF260).\nPreconfigured Linux distros like Ubuntu, Mint, Manjaro, etc.. already provided you with some functionality to use your printer/scanner. All you need to do is just log in to your favorite DE, search for \u0026ldquo;printer\u0026rdquo; in the application launcher, click on the \u0026ldquo;Add a printer\u0026rdquo; button and it will magically discover your Wi-Fi wireless or plugged-in printer, install all drivers for that specific printer and\u0026hellip; it\u0026rsquo;s ready for use.\nIn this guide, we will archive similar easy-to-use functionality with some pretty good GTK applications.\nInstallation Setting up a printer on Arch Linux can be done using the CUPS (Common UNIX Printing System) software. Here are the general steps to set up a printer on Arch Linux:\nInstall CUPS:\n$ sudo pacman -S cups Then, start the CUPS service, and enable it automatically at boot in systemd:\n$ sudo systemctl enable --now cups Add your user to the lp group. User will have permission to access the printer.\n$ sudo usermod -aG lp $USER Make sure to establish a connection between your computer and the printer either via a USB cable or a network connection.\nAt this moment, we are ready to install the graphical program. There are several programs available but I typically install simple and small GTK program called system-config-printer.\n$ sudo pacman -S system-config-printer To get started, open the program and you will see the \u0026ldquo;Add\u0026rdquo; button at the center of the screen. Click on this button, and the program will scan for your printer. From the list that appeared, chose the model of your printer. In the next step, the program should automatically detect and install the drivers for your printer.\nI personally used a Canon MF260 printer and did not encounter any issues during this process. However, I have heard that some users may experience difficulty if their printer or drivers are not detected. Troubleshooting section may help you.\nTest Page References Troubleshooting\nCUPS/Printer-specific problems CUPS/Troubleshooting Guides\nCUPS Arch Wiki Youtube\nHow To Install Printers On Linux How to Install a Printer in Arch Linux! ","permalink":"https://wittyjudge.github.io/posts/arch-linux-printer-install/","summary":"I have been using Arch Linux for about 3 years now and only recently I needed to print and scan documents with my office printer (Canon MF260).\nPreconfigured Linux distros like Ubuntu, Mint, Manjaro, etc.. already provided you with some functionality to use your printer/scanner. All you need to do is just log in to your favorite DE, search for \u0026ldquo;printer\u0026rdquo; in the application launcher, click on the \u0026ldquo;Add a printer\u0026rdquo; button and it will magically discover your Wi-Fi wireless or plugged-in printer, install all drivers for that specific printer and\u0026hellip; it\u0026rsquo;s ready for use.","title":"Arch Linux Printer Install with CUPS"},{"content":"Introduction WireGuard is a lightweight communication protocol that implements encrypted virtual privacy network (VPN).\nIn my humble opinion, if you are simple user, you should use VPN, because:\nIt gives you more freedom to access the internet safely from your smartphone or laptop when connected to a doubt network, like any public WiFi. You have an access to websites blocked in your country for some reasons. WireGuard is so awesome. But why? Minimal code base In fact, it\u0026rsquo;s implemented in less then 4,000 lines of code. It\u0026rsquo;s much easier to audit and reviewing the code for security vulnerabilities.\nFor example, OpenVPN has approximently 600,000 and IPsec around 400,000. WireGuard stands out significantly.\nModern cryptography Noise protocol framework Curve25519 ChaCha20 SipHash-2-4 BLAKE2s HKDF You can read more about WireGuard\u0026rsquo;s cryptography on the official website or in the technical white paper [PDF]\nIncredibly fast Check out the performance comparison charts done by the Jason Donenfeld, the WireGuard author.\nBenchmarked alongside IPSec in two modes and OpenVPN. CPUs: Intel Core i7-3820QM and Intel Core i7-5200U. Ethernet Cards: Intel 82579LM and Intel I218LM gigabit Ethernet. If you\u0026rsquo;re interested in setting up WireGuard on your own server, keep reading.\nPrerequisites To follow this tutorial, you will need:\nThe setup steps are very similar, so you\u0026rsquo;re free to use any Linux distribution you want, but in this guide I will use Ubuntu 20.04. I would recommend you choosing a server with unlimited traffic or at least 1000 GB. You will need a client machine that you will use to connect to your WireGuard server. In that guide, we will create configs for two clients, android and linux. Setup steps Connect to your server.\nssh root@\u0026lt;ip\u0026gt; Step 1 - Update your system Update system packages to up-to-date version.\napt update apt upgrade I also prefer to use neovim as my editor.\napt install neovim Step 2 - Installing WireGuard on server apt install wireguard Step 3 - Enable IP forwarding on the server echo \u0026#34;net.ipv4.ip_forward=1\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf Check out that the string was added.\nsysctl -p net.ipv4.ip_forward = 1 Step 4 - Generate public and private keys of server and clients Change directory to /etc/wireguard.\ncd /etc/wireguard Generate public and private server keys.\nwg genkey | tee privatekey | wg pubkey | tee publickey Then, generate keys for our clients. Initialy, I prefer to create folder with the nickname or device of client that will use VPN. In this guide, I will create configs for two clients, android and linux.\nmkdir android mkdir linux Then, generate keys inside created folders.\nwg genkey | tee android/privatekey | wg pubkey | tee android/publickey wg genkey | tee linux/privatekey | wg pubkey | tee linux/publickey Step 5 - Create server config Create config file and edit it.\ntouch wg0.conf wg0.conf will result in an interface named wg0 therefore you can rename the file if you fancy something different.\nnvim wg0.conf Copy and paste following code to the wg0.conf file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Interface] Address = 10.0.0.1/24 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE ListenPort = 51820 PrivateKey = \u0026lt;Server Private Key\u0026gt; [Peer] PublicKey = \u0026lt;Android client public key\u0026gt; AllowedIPs = 10.0.0.5/32 [Peer] PublicKey = \u0026lt;Linux client public key\u0026gt; AllowedIPs = 10.0.0.6/32 Take a look at server\u0026rsquo;s PrivateKey and peer\u0026rsquo;s PublicKey sections. It requires to copy and paste keys we generated recently.\nStep 5 - Start the WireGuard server Now start the service.\nsystemctl enable wg-quick@wg0 systemctl start wg-quick@wg0 Double check that the WireGuard service is active with the following command. You have to see active (running) in the output:\nwg show wg0 interface: wg0 public key: \u0026lt;Public server key here\u0026gt; private key: (hidden) listening port: 51820 peer: \u0026lt;Public adroid client key here\u0026gt; allowed ips: 10.0.0.5/32 peer: \u0026lt;Public linux client key here\u0026gt; allowed ips: 10.0.0.6/32 systemctl status wg-quick@wg0 ● wg-quick@wg0.service - WireGuard via wg-quick(8) for wg0 Loaded: loaded (/lib/systemd/system/wg-quick@.service; enabled; vendor preset: enabled) Active: active (exited) since Thu 2022-04-14 19:08:04 UTC; 49min ago Docs: man:wg-quick(8) man:wg(8) https://www.wireguard.com/ https://www.wireguard.com/quickstart/ https://git.zx2c4.com/wireguard-tools/about/src/man/wg-quick.8 https://git.zx2c4.com/wireguard-tools/about/src/man/wg.8 Process: 32190 ExecStart=/usr/bin/wg-quick up wg0 (code=exited, status=0/SUCCESS) Main PID: 32190 (code=exited, status=0/SUCCESS) Apr 14 19:08:04 wireguard systemd[1]: Starting WireGuard via wg-quick(8) for wg0... Apr 14 19:08:04 wireguard wg-quick[32190]: [#] ip link add wg0 type wireguard Apr 14 19:08:04 wireguard wg-quick[32190]: [#] wg setconf wg0 /dev/fd/63 Apr 14 19:08:04 wireguard wg-quick[32190]: [#] ip -4 address add 10.0.0.1/24 dev wg0 Apr 14 19:08:04 wireguard wg-quick[32190]: [#] ip link set mtu 1420 up dev wg0 Apr 14 19:08:04 wireguard wg-quick[32190]: [#] iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE Apr 14 19:08:04 wireguard systemd[1]: Finished WireGuard via wg-quick(8) for wg0. Step 6 - Create client config (Android) Create file called android-client.conf and add the following content.\n[Interface] PrivateKey = \u0026lt;Android client private key\u0026gt; Address = 10.0.0.5/24 DNS = 1.1.1.1 [Peer] PublicKey = \u0026lt;Server public key\u0026gt; Endpoint = \u0026lt;SERVER-IP\u0026gt;:51820 AllowedIPs = 0.0.0.0/0 PersistentKeepalive = 20 AllowedIPs = 0.0.0.0/0 will allow you to route all traffic through the VPN tunnel.\nNow we need to transfer this config to the smartphone. Certainly, you can somehow move this file, but it\u0026rsquo;s more convenient to use a QR-code.\nInstall qrencode.\napt install qrencode Use it\nqrencode -t ansiutf8 \u0026lt; android-client.conf After that we will see the QR code in terminal. All we have to do is to scan it using WireGuard app on the mobile phone. You can install it in Play Market or F-Droid\n","permalink":"https://wittyjudge.github.io/posts/setup-wireguard-vpn/","summary":"Introduction WireGuard is a lightweight communication protocol that implements encrypted virtual privacy network (VPN).\nIn my humble opinion, if you are simple user, you should use VPN, because:\nIt gives you more freedom to access the internet safely from your smartphone or laptop when connected to a doubt network, like any public WiFi. You have an access to websites blocked in your country for some reasons. WireGuard is so awesome. But why?","title":"How to set up WireGuard on your own Ubuntu 20.04 server"}]